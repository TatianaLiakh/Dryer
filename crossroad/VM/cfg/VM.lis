    1          PROGR VERIFIER
    2          {
    3          	TACT 50;
    4          	CONST ON 1;
    5          	CONST OFF 0;
    6          	CONST PCyclesDelay 200; /*20 сек*/
    7          	CONST KCyclesDelay 150; /*15 сек*/
    8          	CONST AlgorithmDelay 10; /*1 сек*/
    9          	CONST TestIdling 370; /*37 сек*/
   10          
   11          	/*Набор команд для VERIFIER(блок верификации)*/
   12          	ENUM 
   13          	{
   14          		SCM2VM_TEST_RUN_CAR,
   15          		SCM2VM_TEST_RUN_WRONG_CAR,
   16          		SCM2VM_TEST_RUN_TWO_CARS, 
   17          		SCM2VM_FINISH_VERIFICATION
   18          	};
   19          
   20          	/*Набор команд для DISPATCHER(блок управления сценарием) от VERIFIER(блока верификации)*/
   21          	ENUM
   22          	{
   23          		VM2SCM_START_VERIFICATION,
   24          		VM2SCM_NEXT_TEST
   25          	};
   26          
   27          	/*Набор Команд для GUI */
   28          	ENUM
   29          	{
   30          		VM2GUI_START_TEST_RUN_CAR,
   31          		VM2GUI_START_TEST_RUN_WRONG_CAR,
   32          		VM2GUI_START_TEST_RUN_TWO_CARS,
   33          		VM2GUI_TEST_PASSED_NORMAL_OPEN_ROAD_DELAY, 
   34          		VM2GUI_TEST_PASSED_NORMAL_CLOSE_ROAD_DELAY,
   35          		VM2GUI_TEST_FAILED_NORMAL_OPEN_ROAD_DELAY,
   36          		VM2GUI_TEST_FAILED_NORMAL_CLOSE_ROAD_DELAY,
   37          		VM2GUI_END_VERIFICATION
   38          	};
   39          	
   40          	FUNCTION INT SendMsgSCMCode(INT);
   41          	FUNCTION INT SendMsgGUICode(INT);
   42          	FUNCTION INT GetNextMsgFromSCM(VOID);
   43          	FUNCTION INT GetMsgCodeFromSCM(VOID);
   44          
   45          	INPUT  LOG_CA_INPUT_PORT 0 0 8; /* имя, базовый адрес, доп. адр. порта, 8бит */
   46          	INPUT  LOG_CA_OUTPUT_PORT  0 1 8; /* имя, базовый адрес, доп. адр. порта, 8бит */
   47          	
   48          	PROC Init
   49          	{	
   50          		LOG I_CAR_NEAR_CROSSROAD = {LOG_CA_INPUT_PORT[1]} FOR ALL;
   51          		LOG I_SWITCH_TRAFFIC_LIGHT = {LOG_CA_OUTPUT_PORT[1]} FOR ALL;
   52          				
   53          		STATE Start 
   54          		{	
   55          			SendMsgSCMCode(VM2SCM_START_VERIFICATION); 	
   56          			START PROC ReceiveSCMOutputMsg;
   57          			STOP;
   58          		}
   59          	} 
   60          	
   61          	PROC ReceiveSCMOutputMsg
   62          	{  
   63          		INT SCMsgCode LOCAL; 
   64          		STATE Start
   65          		{
   66          			/*  читаем код и параметр события из кольцевого буфера в структуру */
   67          			IF(GetNextMsgFromSCM()) 
   68          			{
   69          				SCMsgCode = GetMsgCodeFromSCM();
   70          				SWITCH (SCMsgCode) 				
   71          				{				
   72          					CASE SCM2VM_TEST_RUN_CAR:
   73          						SendMsgGUICode(VM2GUI_START_TEST_RUN_CAR);
   74          						START PROC NormalOpenRoadDelayControl;						
   75          						START PROC NormalCloseRoadDelayControl;
   76          						START PROC Terminator; 
   77          						BREAK;
   78          						
   79          					CASE SCM2VM_TEST_RUN_WRONG_CAR:
   80          						SendMsgGUICode(VM2GUI_START_TEST_RUN_WRONG_CAR);
   81          						START PROC NormalOpenRoadDelayControl;						
   82          						START PROC NormalCloseRoadDelayControl;
   83          						START PROC Terminator; 
   84          						BREAK;
   85          					
   86          					CASE SCM2VM_TEST_RUN_TWO_CARS:
   87          						SendMsgGUICode(VM2GUI_START_TEST_RUN_TWO_CARS);
   88          						START PROC NormalOpenRoadDelayControl;						
   89          						START PROC NormalCloseRoadDelayControl;
   90          						START PROC Terminator; 
   91          						BREAK;
   92          
   93          					CASE SCM2VM_FINISH_VERIFICATION:
   94          						SendMsgGUICode(VM2GUI_END_VERIFICATION);
   95          						STOP PROC Terminator; 
   96          						STOP;
   97          						BREAK;
   98          				}
   99          			}
  100          			LOOP;
  101          		}
  102          	}
  103          	
  104          	PROC Terminator
  105          	{
  106          		STATE Idling
  107          		{
  108          			TIMEOUT TestIdling SET NEXT;
  109          		}
  110          		STATE Report
  111          		{			
  112          			/*NormalOpenRoadDelayControl*/
  113          			IF(PROC NormalOpenRoadDelayControl SET STATE ACTIVE)
  114          			{
  115          				SendMsgGUICode(VM2GUI_TEST_PASSED_NORMAL_OPEN_ROAD_DELAY);
  116          			}
  117          			IF(PROC NormalOpenRoadDelayControl SET STATE ERROR)
  118          			{
  119          				SendMsgGUICode(VM2GUI_TEST_FAILED_NORMAL_OPEN_ROAD_DELAY);
  120          			}
  121          
  122          			STOP PROC NormalOpenRoadDelayControl;
  123          			
  124          			/*NormalCloseRoadDelayControl*/		
  125          			IF(PROC NormalCloseRoadDelayControl SET STATE ACTIVE)
  126          			{
  127          				SendMsgGUICode(VM2GUI_TEST_PASSED_NORMAL_CLOSE_ROAD_DELAY);
  128          			}
  129          
  130          			IF(PROC NormalCloseRoadDelayControl SET STATE ERROR)
  131          			{
  132          				SendMsgGUICode(VM2GUI_TEST_FAILED_NORMAL_CLOSE_ROAD_DELAY);
  133          			}
  134          			 
  135          			STOP PROC NormalCloseRoadDelayControl; 			
  136          			SendMsgSCMCode(VM2SCM_NEXT_TEST);
  137          			STOP;
  138          		}	
  139          	}
  140          
  141          
  142          /*Проверка требования: Если появилась машина со стороны сельской дороги, то дорога откроется ровно через P тактов*/
  143          	PROC NormalOpenRoadDelayControl
  144          	{
  145          		FROM PROC Init I_CAR_NEAR_CROSSROAD, I_SWITCH_TRAFFIC_LIGHT;
  146          		
  147          		STATE WaitingOfCar /*Ждем для переключения датчика*/
  148          		{
  149          			IF(I_CAR_NEAR_CROSSROAD == ON) 
  150          				SET NEXT;
  151          		}		
  152          
  153          		STATE WaitingPCycles /*Ждем(Р тактов)*/
  154          		{
  155          			IF(I_SWITCH_TRAFFIC_LIGHT == ON) 
  156          				ERROR;
  157          			TIMEOUT PCyclesDelay SET NEXT;
  158          		}
  159          		
  160          		STATE PCyclesControl /*Проверяем состояние датчика после Р тактов*/
  161          		{
  162          			IF(I_SWITCH_TRAFFIC_LIGHT == ON) 
  163          				SET NEXT;
  164          			TIMEOUT AlgorithmDelay ERROR;
  165          		}	
  166          		
  167          		STATE Idiling
  168          		{
  169          			LOOP;
  170          		}
  171          	}
  172          
  173          /*Проверка требования: Между открытием и закрытием сельской дороги должно пройти ровно K тактов*/
  174          	PROC NormalCloseRoadDelayControl
  175          	{
  176          		FROM PROC Init I_CAR_NEAR_CROSSROAD, I_SWITCH_TRAFFIC_LIGHT;
  177          
  178          		STATE Start /*Ждем пока светофор переключится*/
  179          		{
  180          			IF(I_SWITCH_TRAFFIC_LIGHT == ON) 
  181          				SET NEXT;
  182          		}
  183          		
  184          		STATE WaitingKCycles /*Ждем(K тактов)*/
  185          		{
  186          			IF(I_SWITCH_TRAFFIC_LIGHT == OFF) 
  187          				ERROR;
  188          			TIMEOUT KCyclesDelay SET NEXT;
  189          		}
  190          		
  191          		STATE KCyclesControl /*Проверяем состояние датчика после Р тактов*/
  192          		{
  193          			IF(I_SWITCH_TRAFFIC_LIGHT == OFF) SET NEXT;
  194          				TIMEOUT AlgorithmDelay ERROR;
  195          		}
  196          		
  197          		STATE Idiling
  198          		{
  199          			LOOP;
  200          		}
  201          	}
  202          }
%RCSL-I-SUMMARY, Completed with 0 error(s).
%RCSL-I-SUMMARY, Completed with 0 warning(s).

 %RCSL-I-SUMMARY, Completed with 0 error(s).