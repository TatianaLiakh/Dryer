PROGR VERIFIER
{
	TACT 50;
	CONST ON 1;
	CONST OFF 0;
	CONST PCyclesDelay 200; /*20 сек*/
	CONST KCyclesDelay 150; /*15 сек*/
	CONST AlgorithmDelay 10; /*1 сек*/
	CONST TestIdling 370; /*37 сек*/

	/*Набор команд для VERIFIER(блок верификации)*/
	ENUM 
	{
		SCM2VM_TEST_RUN_CAR,
		SCM2VM_TEST_RUN_WRONG_CAR,
		SCM2VM_TEST_RUN_TWO_CARS, 
		SCM2VM_FINISH_VERIFICATION
	};

	/*Набор команд для DISPATCHER(блок управления сценарием) от VERIFIER(блока верификации)*/
	ENUM
	{
		VM2SCM_START_VERIFICATION,
		VM2SCM_NEXT_TEST
	};

	/*Набор Команд для GUI */
	ENUM
	{
		VM2GUI_START_TEST_RUN_CAR,
		VM2GUI_START_TEST_RUN_WRONG_CAR,
		VM2GUI_START_TEST_RUN_TWO_CARS,
		VM2GUI_TEST_PASSED_NORMAL_OPEN_ROAD_DELAY, 
		VM2GUI_TEST_PASSED_NORMAL_CLOSE_ROAD_DELAY,
		VM2GUI_TEST_FAILED_NORMAL_OPEN_ROAD_DELAY,
		VM2GUI_TEST_FAILED_NORMAL_CLOSE_ROAD_DELAY,
		VM2GUI_END_VERIFICATION
	};
	
	FUNCTION INT SendMsgSCMCode(INT);
	FUNCTION INT SendMsgGUICode(INT);
	FUNCTION INT GetNextMsgFromSCM(VOID);
	FUNCTION INT GetMsgCodeFromSCM(VOID);

	INPUT  LOG_CA_INPUT_PORT 0 0 8; /* имя, базовый адрес, доп. адр. порта, 8бит */
	INPUT  LOG_CA_OUTPUT_PORT  0 1 8; /* имя, базовый адрес, доп. адр. порта, 8бит */
	
	PROC Init
	{	
		LOG I_CAR_NEAR_CROSSROAD = {LOG_CA_INPUT_PORT[1]} FOR ALL;
		LOG I_SWITCH_TRAFFIC_LIGHT = {LOG_CA_OUTPUT_PORT[1]} FOR ALL;
				
		STATE Start 
		{	
			SendMsgSCMCode(VM2SCM_START_VERIFICATION); 	
			START PROC ReceiveSCMOutputMsg;
			STOP;
		}
	} 
	
	PROC ReceiveSCMOutputMsg
	{  
		INT SCMsgCode LOCAL; 
		STATE Start
		{
			/*  читаем код и параметр события из кольцевого буфера в структуру */
			IF(GetNextMsgFromSCM()) 
			{
				SCMsgCode = GetMsgCodeFromSCM();
				SWITCH (SCMsgCode) 				
				{				
					CASE SCM2VM_TEST_RUN_CAR:
						SendMsgGUICode(VM2GUI_START_TEST_RUN_CAR);
						START PROC NormalOpenRoadDelayControl;						
						START PROC NormalCloseRoadDelayControl;
						START PROC Terminator; 
						BREAK;
						
					CASE SCM2VM_TEST_RUN_WRONG_CAR:
						SendMsgGUICode(VM2GUI_START_TEST_RUN_WRONG_CAR);
						START PROC NormalOpenRoadDelayControl;						
						START PROC NormalCloseRoadDelayControl;
						START PROC Terminator; 
						BREAK;
					
					CASE SCM2VM_TEST_RUN_TWO_CARS:
						SendMsgGUICode(VM2GUI_START_TEST_RUN_TWO_CARS);
						START PROC NormalOpenRoadDelayControl;						
						START PROC NormalCloseRoadDelayControl;
						START PROC Terminator; 
						BREAK;

					CASE SCM2VM_FINISH_VERIFICATION:
						SendMsgGUICode(VM2GUI_END_VERIFICATION);
						STOP PROC Terminator; 
						STOP;
						BREAK;
				}
			}
			LOOP;
		}
	}
	
	PROC Terminator
	{
		STATE Idling
		{
			TIMEOUT TestIdling SET NEXT;
		}
		STATE Report
		{			
			/*NormalOpenRoadDelayControl*/
			IF(PROC NormalOpenRoadDelayControl SET STATE ACTIVE)
			{
				SendMsgGUICode(VM2GUI_TEST_PASSED_NORMAL_OPEN_ROAD_DELAY);
			}
			IF(PROC NormalOpenRoadDelayControl SET STATE ERROR)
			{
				SendMsgGUICode(VM2GUI_TEST_FAILED_NORMAL_OPEN_ROAD_DELAY);
			}

			STOP PROC NormalOpenRoadDelayControl;
			
			/*NormalCloseRoadDelayControl*/		
			IF(PROC NormalCloseRoadDelayControl SET STATE ACTIVE)
			{
				SendMsgGUICode(VM2GUI_TEST_PASSED_NORMAL_CLOSE_ROAD_DELAY);
			}

			IF(PROC NormalCloseRoadDelayControl SET STATE ERROR)
			{
				SendMsgGUICode(VM2GUI_TEST_FAILED_NORMAL_CLOSE_ROAD_DELAY);
			}
			 
			STOP PROC NormalCloseRoadDelayControl; 			
			SendMsgSCMCode(VM2SCM_NEXT_TEST);
			STOP;
		}	
	}


/*Проверка требования: Если появилась машина со стороны сельской дороги, то дорога откроется ровно через P тактов*/
	PROC NormalOpenRoadDelayControl
	{
		FROM PROC Init I_CAR_NEAR_CROSSROAD, I_SWITCH_TRAFFIC_LIGHT;
		
		STATE WaitingOfCar /*Ждем для переключения датчика*/
		{
			IF(I_CAR_NEAR_CROSSROAD == ON) 
				SET NEXT;
		}		

		STATE WaitingPCycles /*Ждем(Р тактов)*/
		{
			IF(I_SWITCH_TRAFFIC_LIGHT == ON) 
				ERROR;
			TIMEOUT PCyclesDelay SET NEXT;
		}
		
		STATE PCyclesControl /*Проверяем состояние датчика после Р тактов*/
		{
			IF(I_SWITCH_TRAFFIC_LIGHT == ON) 
				SET NEXT;
			TIMEOUT AlgorithmDelay ERROR;
		}	
		
		STATE Idiling
		{
			LOOP;
		}
	}

/*Проверка требования: Между открытием и закрытием сельской дороги должно пройти ровно K тактов*/
	PROC NormalCloseRoadDelayControl
	{
		FROM PROC Init I_CAR_NEAR_CROSSROAD, I_SWITCH_TRAFFIC_LIGHT;

		STATE Start /*Ждем пока светофор переключится*/
		{
			IF(I_SWITCH_TRAFFIC_LIGHT == ON) 
				SET NEXT;
		}
		
		STATE WaitingKCycles /*Ждем(K тактов)*/
		{
			IF(I_SWITCH_TRAFFIC_LIGHT == OFF) 
				ERROR;
			TIMEOUT KCyclesDelay SET NEXT;
		}
		
		STATE KCyclesControl /*Проверяем состояние датчика после Р тактов*/
		{
			IF(I_SWITCH_TRAFFIC_LIGHT == OFF) SET NEXT;
				TIMEOUT AlgorithmDelay ERROR;
		}
		
		STATE Idiling
		{
			LOOP;
		}
	}
}